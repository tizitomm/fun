# Tom Neilly# Scripting (IS SO FUN I FREAKIN' LOVE IT)# Midterm# CTM After Image Script# 3/18/2015# SYNOPSIS# - Assigns the default 150.212.134.10 address to the machine to gain network connectivity# - Scans the 150.212.134.1 /24 subnet for an open IP address, assigns itself the first available# - Scans the network for names starting with CTMBuild-1, increments by one until it finds the first available,#   assigns that name to itself. This is a default name we can use until it is delivered.# - Adds itself to the upb.pitt.edu domain# - Adds thn16 to the Administrators group in order to use PDQ Deploy on the machine# - Maps to Servy# - Identifies its make, model, Windows version, and architecture# - Tests a path to the Servy share to see if there are available drivers for the machine, if so, copies them#   to the current users desktop# - Enables File and Printer Sharing over DOMAIN ONLY for PDQ Deploy# - Logs all output and saves to the users desktop# - Sends email to thn16@pitt.edu from my tizitomm@gmail.com email address with the log attachment# - Deletes the script, deletes the text files storing hashed passwords# - Restarts################################# REFERENCES ################################################ Storing encrypted credentials# https://www.interworks.com/blogs/trhymer/2013/07/08/powershell-how-encrypt-and-store-credentials-securely-use-automation-script################################# VARIABLE DECLARATIONS ###################################### Shortens the user profile variable to what I prefer to have it set toSet-Variable -Name up -Value $env:USERPROFILE -Confirm:$false ################################# FUNCTION DECLARATIONS ###################################### Scans the 150.212.134.xxx /24 subnet for a free IP address by pinging machines# While a test-connection of 1 packet is returned, increments the IP address by 1# When a test-connection fails, assumes this IP address is free and creates a global# variable of the free IP addressfunction FindIp {	[int]$x = 12			while (Test-Connection 150.212.134.$x -count 1 -quiet)		{		  echo ("150.212.134.$x is IN USE.") | out-file $up\desktop\PSMidterm.txt -append		  $x++		}	echo ("150.212.134.$x is AVAILABLE")	$global:assignIP = "150.212.134.$x" 	echo ("$assignIP will be used for target computer.") | out-file $up\desktop\PSMidterm.txt -append}# Removes all current IP configurations# Uses the global variable to assign the IP addressfunction AssignIP {       # ClearIP       # Get-NetAdapter -Name "Ethernet" | Set-NetIPInterface -Dhcp Enabled       Get-NetAdapter -Name "Ethernet" | Set-NetIPInterface -Dhcp Disabled       myip       # New-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress $assignip -AddressFamily IPv4 -PrefixLength 22 -DefaultGateway 150.212.132.1        Remove-NetIPAddress -IPAddress $myip -Confirm:$false       New-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress $assignip -AddressFamily IPv4 -PrefixLength 22 -Confirm:$false       Start-Sleep -Seconds 30       # Set-DnsClientServerAddress -InterfaceAlias "Ethernet" -ServerAddresses ("150.212.138.69","150.212.138.70") | out-file $up\desktop\PSMidterm.txt -append}# Uses the Resolve-DnsName cmdlet to find an available computer name for temporary use# until it has updates run on it and is delivered.# Searches for computer names starting with CTMBuild1. If machine name exists,# increments the number by one until it finds a machine that does not exist.# Declares a global variable which will later be used to name the machine.function FindComputerName {	$x = 3		while (Resolve-DnsName CTMBuild$x -ErrorAction SilentlyContinue)		{			echo ("CTMBuild$x is being used")			$x++			}	$global:machinename = "CTMBuild$x"	#echo ("The machine name $machinename is available and will be applied.") | out-file $up\desktop\PSMidterm.txt -appendecho ("The machine name $machinename is available and will be applied.")}function AddToDomain {        # Retrieves my credentials that are hashed in a text file    $encrypted = Get-Content C:\thn16.txt | ConvertTo-SecureString	$credential = New-Object System.Management.Automation.PsCredential("pitt-bradford\thn16", $encrypted)    $encryptedWS = Get-Content c:\wscreds.txt | ConvertTo-SecureString    $credentialWS = New-Object System.Management.Automation.PsCredential("ctmws", $encryptedWS)    Rename-Computer -ComputerName $env:computername -NewName $machinename -DomainCredential $credentialWS    Add-Computer -DomainName "upb.pitt.edu" -Force -Credential $credential | out-file $up\desktop\PSMidterm.txt -append}function MapServy {    # Maps to servy so it can download the necessary drivers    # Retrieves my credentials that are hashed in a text file	$encrypted = Get-Content C:\thn16.txt | ConvertTo-SecureString	$credential = New-Object System.Management.Automation.PsCredential("pitt-bradford\thn16", $encrypted)        New-PSDrive -Name Servy -PSProvider FileSystem -Root "\\servy.upb.pitt.edu\programs$" -Description "Maps to Servy" -Credential $credential -Confirm:$false | out-file $up\desktop\PSMidterm.txt -append}# Finds Make, Model, OS Version, OS Bitfunction FindDrivers {    $manuf = (Get-WmiObject -Class:Win32_ComputerSystem).Manufacturer    $model = (Get-WmiObject -Class:Win32_ComputerSystem).Model    $os =  (Get-WmiObject Win32_OperatingSystem).Name    $osbit = (Get-WmiObject Win32_OperatingSystem).OSArchitecture    #echo ("$manuf $model") ("$os $osbit") | out-file $up\desktop\PSMidterm.txt -append        # Manufacturer if/else        if ($manuf.Contains("Hewlett"))        {            $manuf = "HP"         }        elseif ($manuf.Contains("Dell"))        {            $manuf = "Dell"         }        elseif ($manuf.Contains("Gate"))        {            $manuf = "Gateway"        }        # Model        # OS Version        if ($os.Contains("7"))        {            $os = "Windows 7"        }        elseif ($os.Contains("8"))        {            $os = "Windows 8.1"        }        # OS Bit        if ($osbit.Contains("64"))        {            $osbit = "x64"        }        else         {            $osbit = "x86"        }# Sends machine info to logecho ("Machine make/model/operating system ---") ("") ("$manuf $model") ("$os $osbit") | out-file $up\desktop\PSMidterm.txt -append# Tests the path first to check Servy for drivers. If test-path succeeds, returns TRUE. If true, copy drivers to desktop.# If false, logs that the drivers did not exist.$global:path = "\\servy.upb.pitt.edu\programs$\Drivers\Computers\$os\$manuf\$model"        if (Test-Path $path)        {            echo ("Got em!")            Copy-Item \\servy.upb.pitt.edu\programs$\Drivers\Computers\$os\$manuf\$model -Destination $env:userprofile\desktop -Recurse | out-file $up\desktop\PSMidterm.txt -append        }        else         {            echo ("Could not find drivers for this machine on Servy :(") | out-file $up\desktop\PSMidterm.txt -append        }}function ClearIP {        MyIp        Remove-NetIPAddress -IPAddress $myip -PrefixLength 22 -DefaultGateway 150.212.132.1 -Confirm:$false -ErrorAction SilentlyContinue        Get-NetAdapter -Name "Ethernet" | Set-NetIPInterface -Dhcp Enabled -Confirm:$false        Remove-NetRoute -InterfaceAlias "Ethernet" -Confirm:$false        Set-DnsClientServerAddress -InterfaceAlias "Ethernet" -ResetServerAddresses -Confirm:$false}function GmailCreds {        $credential = Get-Credential -Message "ENTER GMAIL CREDENTIALS! FULL GMAIL ADDRESS AND PASSWORD"        $credential.Password | ConvertFrom-SecureString | Set-Content c:\tizitomm.txt}function DomainCreds {        $credential = Get-Credential -Message "ENTER PITT-BRADFORD CREDENTIALS! PITT-BRADFORD\THN16 AND PASSWORD"        $credential.Password | ConvertFrom-SecureString | Set-Content c:\thn16.txt}function WSCreds {        $credential = Get-Credential -Message "ENTER CTMWS CREDENTIALS! .\CTMWS AND PASSWORD"        $credential.Password | ConvertFrom-SecureString | Set-Content c:\wscreds.txt}function MyIP {$global:myip = (Get-NetAdapter | where name -eq 'Ethernet' | Get-NetIPAddress | where addressfamily -eq 'IPv4').ipaddress}function AdminSchTask {$action = New-ScheduledTaskAction -Execute "C:\Windows\System32\WindowsPowerShell\v1.0\Powershell.exe" -Argument "C:\MakeTomAdmin.ps1"$trigger = New-ScheduledTaskTrigger -AtLogOn$user = "ctmws"Register-ScheduledTask -TaskName MakeTommyboyAdministrator -User $user -Action $action -RunLevel Highest -Trigger $trigger -Description "Makes Tom an administrator"}# Sends email with log attachment to Tom and Bobfunction SendLog {	param([string]$to)	$machinename = "Temp1"	$from = "tizitomm@gmail.com"	#$to = "thn16@pitt.edu"	$cc = "sellison@pitt.edu"	$attachment = "$up\desktop\psmidterm.txt"	$subject = "PowerShell Notification : Machine Info"	$body = "PowerShell Notification - Please see attachment."	# Retrieves my encrypted Gmail credentials from another script,	# decrypts them, and uses them to send the email. This prevents	# me from having any interaction and leaves things to be automated.	$encrypted = Get-Content C:\tizitomm.txt | ConvertTo-SecureString	$credential = New-Object System.Management.Automation.PsCredential($from, $encrypted)    $smtpserver = "smtp.gmail.com"        $smtpport = "587"	$smtpclient = New-Object Net.Mail.SmtpClient($smtpserver, $smtpport)	$smtpclient.EnableSsl = $true	$smtpclient.Credentials = $credential	$smtpclient.Send($from, $to, $subject, $body)	Send-MailMessage -From $From -to $To -Subject $Subject -cc $cc -BodyAsHTML $Body -SmtpServer $SMTPServer -port $SMTPPort -UseSsl -Credential $credential -Attachments $attachment}function DeleteScripts {    Remove-Item C:\thn16.txt  -ErrorAction SilentlyContinue    Remove-Item C:\tizitomm.txt -ErrorAction SilentlyContinue    Remove-Item C:\PSMidterm.ps1 -ErrorAction SilentlyContinue}################################## PROMPT TO START SCRIPT ##################################Add-Type -AssemblyName System.Windows.Forms$output = [System.Windows.Forms.MessageBox]::Show("Would you like to start the AfterImage script?","AfterImage.ps1 Prompt",4)if ($output -eq 'YES'){    ################################### START SCRIPT ############################################    # Starts calling all functions in the script    DomainCreds    GmailCreds    ## Sets Default IP Address    ClearIP    Get-NetAdapter -Name "Ethernet" | Set-NetIPInterface -Dhcp Disabled    New-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress 150.212.134.11 -AddressFamily IPv4 -PrefixLength 22 -DefaultGateway 150.212.132.1 -Confirm:$false | out-file $up\desktop\PSMidterm.txt -append    Set-NetIPAddress -InterfaceAlias "Ethernet" -IPAddress 150.212.134.11 -AddressFamily IPv4 -PrefixLength 22 | out-file $up\desktop\PSMidterm.txt -append    Set-DnsClientServerAddress -InterfaceAlias "Ethernet" -ServerAddresses ("150.212.138.69","150.212.138.70") | out-file $up\desktop\PSMidterm.txt -append    # Turns on file and printer sharing across domain for PDQ Deploy to function    Set-NetFirewallRule -DisplayGroup "File and Printer Sharing" -Enabled True -Profile Domain    FindIp    AssignIP    FindComputerName    AddToDomain    MapServy    FindDrivers    SendLog thn16@pitt.edu    AdminSchTask    DeleteScripts    Restart-Computer}else {    [System.Windows.Forms.MessageBox]::Show("Okay, the script will not start at this time.","AfterImage.ps1 Prompt");}